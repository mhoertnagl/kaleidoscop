use std::str::FromStr;

use crate::ast::Unit;
use crate::ast::Stmt;
use crate::ast::Expr;
use crate::ast::Opcode;

grammar;

// https://github.com/Storyyeller/cubiml-demo/blob/master/src/grammar.lalr
#[inline]
Comma<T>: Vec<T> = {
  <i1: T> <i2:("," T)*> => {
    let mut items = vec![i1];
    items.extend(i2.into_iter().map(|e| e.1));
    items
  }
};

pub Unit: Unit = {
  <stmts:Stmt*> => Unit::Body{ stmts }
};

Stmt: Stmt = {
  "let" <name:Id> "=" <expr:Expr> ";" =>
    Stmt::Let{ name, expr },

  "def" <name:Id> "(" <params:Comma<Id>?> ")" "{"
    <stmts:Stmt*> 
  "}" =>
    Stmt::Def{ name, params, stmts },

  <name:Id> "=" <expr:Expr> ";" =>
    Stmt::Assign{ name, expr },

  // TODO: Acuatlly function call is enough.
  <expr:Expr> ";" =>
    Stmt::Expr(expr),

  <ifstmt:IfStmt> => 
    ifstmt,
  // "if" <cond:Expr> "{" 
  //   <cons:Stmt*> 
  // "}" =>
  //   Stmt::If{ cond, cons, alt: None },

  // "if" <cond:Expr> "{" 
  //   <cons:Stmt*> 
  // "}" "else" "{"
  //   <alt:Stmt*> 
  // "}" =>
  //   Stmt::If{ cond, cons, alt: Some(alt) },

  "return" <expr:Expr> ";" =>
    Stmt::Return(expr),
}

IfStmt: Stmt = {
  "if" <cond:Expr> "{" 
    <cons:Stmt*> 
  "}" =>
    Stmt::If{ cond, cons },

  "if" <cond:Expr> "{" 
    <cons:Stmt*> 
  "}" "else" "{"
    <alt:Stmt*> 
  "}" =>
    Stmt::IfElse{ cond, cons, alt },

  "if" <cond:Expr> "{" 
    <cons:Stmt*> 
  "}" "else" <elsif:IfStmt> =>
    Stmt::IfElse{ cond, cons, alt: vec![elsif] },
}

  // "print" <e:Expr> => Stmt::Expr {
  //   expr: e,
  // },

Expr: Box<Expr> = {
  <left:Expr> <op:ExprOp> <right:Factor> =>
    Box::new(Expr::BinOp{ left, op, right }),

  AdditiveExpr,
};

ExprOp: Opcode = {
  "==" => Opcode::EQ,
  "!=" => Opcode::NE,
  "<" => Opcode::LT,
  "<=" => Opcode::LE,
  ">" => Opcode::GT,
  ">=" => Opcode::GE
};

AdditiveExpr: Box<Expr> = {
  <left:Expr> <op:AdditiveExprOp> <right:Factor> =>
    Box::new(Expr::BinOp{ left, op, right }),

  Factor,
};

AdditiveExprOp: Opcode = {
  "+" => Opcode::Add,
  "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
  <left:Factor> <op:FactorOp> <right:Term> =>
    Box::new(Expr::BinOp{ left, op, right }),

  Term,
};

FactorOp: Opcode = {
  "*" => Opcode::Mul,
  "/" => Opcode::Div,
};

Term: Box<Expr> = {
  Num => Box::new(Expr::Num(<>)),
  Id => Box::new(Expr::Id(<>)),
  Text => Box::new(Expr::Text(<>)),
  Call => <>,
  "(" <e:Expr> ")" => e,
};

Call: Box<Expr> = {
  <name:Id> "(" <args:Comma<Expr>?> ")" =>
    Box::new(Expr::Call{ name, args }),
};

Num: u64 = {
  r"[0-9]+" => u64::from_str(<>).unwrap(),
};

Id: String = {
  r"[a-zA-Z][a-zA-Z0-9]*" => <>.to_string(),
};

// TODO: escape sequences incl. \'
Text: String = {
  r"'[^']*'" => <>.trim_matches('\'').to_string(),
}

// Num: f64 = {
//   r"-?[0-9]+" => f64::from_str(<>).unwrap(),
//   r"-?[0-9]*\.[0-9]*" => f64::from_str(<>).unwrap()
// };

match {
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  _,
} 
